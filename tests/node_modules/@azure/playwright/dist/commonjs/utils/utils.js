"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.getTestRunConfig = exports.validatePlaywrightVersion = exports.getVersionInfo = exports.fetchOrValidateAccessToken = exports.warnIfAccessTokenCloseToExpiry = exports.validateMptPAT = exports.ValidateRunID = exports.validateServiceUrl = exports.getServiceWSEndpoint = exports.getAndSetRunId = exports.isValidGuid = exports.getServiceBaseURL = exports.getAccessToken = exports.populateValuesFromServiceUrl = exports.throwErrorWithFailureMessage = exports.exitWithFailureMessage = exports.getPackageVersion = exports.parseJwt = exports.getPlaywrightVersion = void 0;
exports.getTestRunApiUrl = getTestRunApiUrl;
exports.isNullOrEmpty = isNullOrEmpty;
exports.getRunName = getRunName;
exports.extractErrorMessage = extractErrorMessage;
const tslib_1 = require("tslib");
const constants_js_1 = require("../common/constants.js");
const messages_js_1 = require("../common/messages.js");
const logger_js_1 = require("../common/logger.js");
const node_process_1 = tslib_1.__importDefault(require("node:process"));
const node_crypto_1 = require("node:crypto");
const parseJwt_js_1 = require("./parseJwt.js");
const getPlaywrightVersion_js_1 = require("./getPlaywrightVersion.js");
const entraIdAccessToken_js_1 = require("../common/entraIdAccessToken.js");
const cIInfoProvider_js_1 = require("./cIInfoProvider.js");
const child_process_1 = require("child_process");
const getPackageVersion_js_1 = require("./getPackageVersion.js");
// Re-exporting for backward compatibility
var getPlaywrightVersion_js_2 = require("./getPlaywrightVersion.js");
Object.defineProperty(exports, "getPlaywrightVersion", { enumerable: true, get: function () { return getPlaywrightVersion_js_2.getPlaywrightVersion; } });
var parseJwt_js_2 = require("./parseJwt.js");
Object.defineProperty(exports, "parseJwt", { enumerable: true, get: function () { return parseJwt_js_2.parseJwt; } });
const getPackageVersion = () => {
    // hacky way to get package version
    // try from dist folder first (customer perspective)
    const distVersion = (0, getPackageVersion_js_1.getPackageVersionFromFolder)("../../../");
    if (distVersion) {
        return distVersion;
    }
    // if not found, try from src folder (internal test suite)
    const srcVersion = (0, getPackageVersion_js_1.getPackageVersionFromFolder)("../../");
    if (srcVersion) {
        return srcVersion;
    }
    return "unknown-version";
};
exports.getPackageVersion = getPackageVersion;
// const playwrightServiceConfig = new PlaywrightServiceConfig();
const exitWithFailureMessage = (error, errorDetails) => {
    console.log();
    if (error.formatWithErrorDetails && errorDetails) {
        console.error(error.formatWithErrorDetails(errorDetails));
    }
    else {
        console.error(error.message);
    }
    // eslint-disable-next-line n/no-process-exit
    node_process_1.default.exit(1);
};
exports.exitWithFailureMessage = exitWithFailureMessage;
const throwErrorWithFailureMessage = (error, errorDetails) => {
    console.log();
    const finalMessage = error.formatWithErrorDetails && errorDetails
        ? error.formatWithErrorDetails(errorDetails)
        : error.message;
    throw new Error(finalMessage);
};
exports.throwErrorWithFailureMessage = throwErrorWithFailureMessage;
const populateValuesFromServiceUrl = () => {
    // Service URL format: wss://<region>.api.playwright.microsoft.com/accounts/<workspace-id>/browsers
    const url = node_process_1.default.env["PLAYWRIGHT_SERVICE_URL"];
    if (url) {
        const parts = url.split("/");
        if (parts.length > 2) {
            const subdomainParts = parts[2].split(".");
            const region = subdomainParts.length > 0 ? subdomainParts[0] : null;
            const domain = subdomainParts.slice(2).join(".");
            const accountId = parts[4];
            return { region: region, domain: domain, accountId: accountId };
        }
    }
    return null;
};
exports.populateValuesFromServiceUrl = populateValuesFromServiceUrl;
const getAccessToken = () => {
    return node_process_1.default.env[constants_js_1.ServiceEnvironmentVariable.PLAYWRIGHT_SERVICE_ACCESS_TOKEN];
};
exports.getAccessToken = getAccessToken;
const getServiceBaseURL = () => {
    return node_process_1.default.env[constants_js_1.ServiceEnvironmentVariable.PLAYWRIGHT_SERVICE_URL];
};
exports.getServiceBaseURL = getServiceBaseURL;
const isValidGuid = (guid) => {
    if (!guid) {
        return false;
    }
    const guidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
    return guidRegex.test(guid);
};
exports.isValidGuid = isValidGuid;
const getAndSetRunId = () => {
    const runId = (0, node_crypto_1.randomUUID)();
    node_process_1.default.env[constants_js_1.InternalEnvironmentVariables.MPT_SERVICE_RUN_ID] = runId;
    return runId;
};
exports.getAndSetRunId = getAndSetRunId;
const getServiceWSEndpoint = (runId, os, apiVersion) => {
    return `${(0, exports.getServiceBaseURL)()}?runId=${encodeURIComponent(runId)}&os=${os}&api-version=${apiVersion}`;
};
exports.getServiceWSEndpoint = getServiceWSEndpoint;
const validateServiceUrl = () => {
    const serviceUrl = (0, exports.getServiceBaseURL)();
    if (!serviceUrl) {
        (0, exports.exitWithFailureMessage)(messages_js_1.ServiceErrorMessageConstants.NO_SERVICE_URL_ERROR);
    }
};
exports.validateServiceUrl = validateServiceUrl;
const ValidateRunID = (runID) => {
    const isValidRunID = (0, exports.isValidGuid)(runID);
    if (!isValidRunID) {
        const errorMessage = messages_js_1.ServiceErrorMessageConstants.INVALID_RUN_ID_FORMAT.message;
        throw new Error(errorMessage);
    }
};
exports.ValidateRunID = ValidateRunID;
const validateMptPAT = (validationFailureCallback) => {
    try {
        const accessToken = (0, exports.getAccessToken)();
        const result = (0, exports.populateValuesFromServiceUrl)();
        if (!accessToken) {
            validationFailureCallback(messages_js_1.ServiceErrorMessageConstants.NO_AUTH_ERROR);
        }
        const claims = (0, parseJwt_js_1.parseJwt)(accessToken);
        if (!claims.exp) {
            validationFailureCallback(messages_js_1.ServiceErrorMessageConstants.INVALID_MPT_PAT_ERROR);
        }
        if (Date.now() >= claims.exp * 1000) {
            validationFailureCallback(messages_js_1.ServiceErrorMessageConstants.EXPIRED_MPT_PAT_ERROR);
        }
        if (result.accountId !== claims.pwid) {
            validationFailureCallback(messages_js_1.ServiceErrorMessageConstants.WORKSPACE_MISMATCH_ERROR);
        }
    }
    catch (err) {
        logger_js_1.coreLogger.error(err);
        (0, exports.exitWithFailureMessage)(messages_js_1.ServiceErrorMessageConstants.INVALID_MPT_PAT_ERROR);
    }
};
exports.validateMptPAT = validateMptPAT;
const isTokenExpiringSoon = (expirationTime, currentTime) => {
    return expirationTime * 1000 - currentTime <= constants_js_1.Constants.SevenDaysInMS;
};
const warnAboutTokenExpiry = (expirationTime, currentTime) => {
    const daysToExpiration = Math.ceil((expirationTime * 1000 - currentTime) / constants_js_1.Constants.OneDayInMS);
    const expirationDate = new Date(expirationTime * 1000).toLocaleDateString();
    const expirationWarning = `Warning: The access token used for this test run will expire in ${daysToExpiration} days on ${expirationDate}. Generate a new token from the portal to avoid failures. For a simpler, more secure solution, switch to Microsoft Entra ID and eliminate token management. https://learn.microsoft.com/entra/identity/`;
    console.warn(expirationWarning);
};
const warnIfAccessTokenCloseToExpiry = () => {
    const accessToken = (0, exports.getAccessToken)();
    if (!accessToken) {
        throw new Error(messages_js_1.ServiceErrorMessageConstants.NO_AUTH_ERROR.message);
    }
    const claims = (0, parseJwt_js_1.parseJwt)(accessToken);
    const currentTime = Date.now();
    if (isTokenExpiringSoon(claims.exp, currentTime)) {
        warnAboutTokenExpiry(claims.exp, currentTime);
    }
};
exports.warnIfAccessTokenCloseToExpiry = warnIfAccessTokenCloseToExpiry;
const fetchOrValidateAccessToken = async (credential) => {
    const entraIdAccessToken = (0, entraIdAccessToken_js_1.createEntraIdAccessToken)(credential);
    // Fetch a token or refresh if needed in a single call
    if (entraIdAccessToken.doesEntraIdAccessTokenNeedRotation()) {
        await entraIdAccessToken.fetchEntraIdAccessToken();
    }
    const token = (0, exports.getAccessToken)();
    if (!token) {
        throw new Error(messages_js_1.ServiceErrorMessageConstants.NO_AUTH_ERROR.message);
    }
    return token;
};
exports.fetchOrValidateAccessToken = fetchOrValidateAccessToken;
const getVersionInfo = (version) => {
    const regex = /^(\d+)(?:\.(\d+))?(?:\.(\d+))?/;
    const match = version.match(regex);
    const versionInfo = {
        major: 0,
        minor: 0,
        patch: 0,
    };
    versionInfo.major = match && match[1] ? parseInt(match[1], 10) : 0;
    versionInfo.minor = match && match[2] ? parseInt(match[2], 10) : 0;
    versionInfo.patch = match && match[3] ? parseInt(match[3], 10) : 0;
    return versionInfo;
};
exports.getVersionInfo = getVersionInfo;
const validatePlaywrightVersion = () => {
    const minimumSupportedVersion = constants_js_1.Constants.MinimumSupportedPlaywrightVersion;
    const installedVersion = (0, getPlaywrightVersion_js_1.getPlaywrightVersion)();
    const minimumSupportedVersionInfo = (0, exports.getVersionInfo)(minimumSupportedVersion);
    const installedVersionInfo = (0, exports.getVersionInfo)(installedVersion);
    const isInstalledVersionGreater = installedVersionInfo.major > minimumSupportedVersionInfo.major ||
        (installedVersionInfo.major === minimumSupportedVersionInfo.major &&
            installedVersionInfo.minor >= minimumSupportedVersionInfo.minor);
    if (!isInstalledVersionGreater) {
        (0, exports.exitWithFailureMessage)(messages_js_1.ServiceErrorMessageConstants.INVALID_PLAYWRIGHT_VERSION_ERROR);
    }
};
exports.validatePlaywrightVersion = validatePlaywrightVersion;
const getTestRunConfig = (config) => {
    const maxWorkers = config.workers || config.metadata.actualWorkers;
    const frameWorkVersion = config.version;
    const testRunConfig = {
        framework: {
            name: constants_js_1.RunConfigConstants.TEST_FRAMEWORK_NAME,
            version: frameWorkVersion,
            runnerName: constants_js_1.RunConfigConstants.TEST_FRAMEWORK_RUNNERNAME,
        },
        sdkLanguage: constants_js_1.RunConfigConstants.TEST_SDK_LANGUAGE,
        maxWorkers: maxWorkers,
    };
    return testRunConfig;
};
exports.getTestRunConfig = getTestRunConfig;
function getTestRunApiUrl() {
    const result = (0, exports.populateValuesFromServiceUrl)();
    const runId = node_process_1.default.env[constants_js_1.InternalEnvironmentVariables.MPT_SERVICE_RUN_ID];
    if (!result?.region || !result?.domain || !result?.accountId) {
        (0, exports.exitWithFailureMessage)(messages_js_1.ServiceErrorMessageConstants.NO_SERVICE_URL_ERROR);
    }
    const baseUrl = `https://${result?.region}.reporting.api.${result?.domain}/playwrightworkspaces/${result?.accountId}/test-runs`;
    const url = runId ? `${baseUrl}/${runId}` : baseUrl;
    return `${url}?api-version=${constants_js_1.Constants.LatestAPIVersion}`;
}
function isNullOrEmpty(str) {
    return !str || str.trim() === "";
}
async function runCommand(command) {
    return new Promise((resolve, reject) => {
        (0, child_process_1.exec)(command, (error, stdout, stderr) => {
            if (error) {
                reject(error);
                return;
            }
            if (stderr) {
                reject(new Error(stderr));
                return;
            }
            resolve(stdout.trim());
        });
    });
}
async function getRunName(ciInfo) {
    if (ciInfo.providerName === cIInfoProvider_js_1.CI_PROVIDERS.GITHUB &&
        node_process_1.default.env["GITHUB_EVENT_NAME"] === "pull_request") {
        const prNumber = `${node_process_1.default.env["GITHUB_REF_NAME"]?.split("/")[0]}`;
        const prLink = `${node_process_1.default.env["GITHUB_REPOSITORY"]}/pull/${prNumber}`;
        return `PR# ${prNumber} on Repo: ${node_process_1.default.env["GITHUB_REPOSITORY"]} (${prLink})`;
    }
    try {
        const gitVersion = await runCommand(constants_js_1.GitHubActionsConstants.GIT_VERSION_COMMAND);
        if (isNullOrEmpty(gitVersion)) {
            throw new Error("Git is not installed on the machine");
        }
        const isInsideWorkTree = await runCommand(constants_js_1.GitHubActionsConstants.GIT_REV_PARSE);
        if (isInsideWorkTree !== "true") {
            throw new Error("Not inside a git repository");
        }
        const gitCommitMessage = await runCommand(constants_js_1.GitHubActionsConstants.GIT_COMMIT_MESSAGE_COMMAND);
        return gitCommitMessage;
    }
    catch (err) {
        logger_js_1.coreLogger.error(`Error in getting git commit message: ${err}.`);
        return "";
    }
}
function extractErrorMessage(responseBody) {
    if (!responseBody) {
        return "";
    }
    try {
        const errorResponse = JSON.parse(responseBody);
        if (errorResponse.error && errorResponse.error.message) {
            return errorResponse.error.message;
        }
        return responseBody;
    }
    catch (e) {
        return responseBody;
    }
}
//# sourceMappingURL=utils.js.map